import { execSync, spawn } from 'node:child_process';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

export const VERBOSE = process.argv.includes('--verbose');
export const __dirname = dirname(fileURLToPath(import.meta.url));
export const ROOT = join(__dirname, '..', '..');
export const SUPABASE_DIR = join(ROOT, 'packages', 'supabase');
export const DASHBOARD_DIR = join(ROOT, 'apps', 'dashboard');
export const ENV_FILE = join(DASHBOARD_DIR, '.env.local');

// Fixed local development credentials (deterministic for parallel builds)
// These are generated by Supabase CLI based on project_id "fieldmcp" and are consistent across runs
export const LOCAL_SUPABASE_URL = 'http://127.0.0.1:54321';
export const LOCAL_ANON_KEY = 'sb_publishable_ACJWlzQHlZjBrEguHvfOxg_3BJgxAaH';
export const LOCAL_SERVICE_ROLE_KEY =
  'sb_secret_N7UND0UgjKTVK-Uodkm0Hg_xSvEMPvz';

export const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// Constants for timeouts
const STRIPE_WEBHOOK_TIMEOUT_MS = 10000;

/**
 * Spawns a process with shell: true using a single command string.
 * This avoids the Node.js DEP0190 deprecation warning about passing args with shell: true.
 */
export function shellSpawn(command, args, options) {
  const fullCommand = [command, ...args].join(' ');
  return spawn(fullCommand, [], { ...options, shell: true });
}

/**
 * Attaches prefixed output handlers to a spawned process's stdout/stderr streams.
 * @param {import('node:child_process').ChildProcess} proc - The spawned process
 * @param {string} prefix - The prefix label (e.g., 'NEXT', 'SUPABASE')
 * @param {string} color - ANSI color code for the prefix
 */
export function attachPrefixedOutputHandlers(proc, prefix, color) {
  proc.stdout.on('data', (data) => {
    process.stdout.write(`${color}[${prefix}]${colors.reset} ${data}`);
  });

  proc.stderr.on('data', (data) => {
    process.stderr.write(`${color}[${prefix}]${colors.reset} ${data}`);
  });
}

/**
 * Determines if a line of output is important enough to show in non-verbose mode.
 * Filters out noisy output like Docker image status, migration details, ASCII boxes.
 */
function isImportantLine(line) {
  const noise = [
    'Skipped - Image',
    'already present',
    'Applying migration',
    'Seeding data',
    'Seeding globals',
    'Initialising schema',
    'Waiting for health',
    'Starting database',
    'Starting containers',
    'Setting up Edge Functions',
    'Checking for new versions',
    'Getting ready',
    'Compiling',
    '○ Compiling',
    '✓ Compiled',
    'Environments:',
    // ASCII box characters
    '╭',
    '╰',
    '├',
    '┌',
    '└',
    '┐',
    '┘',
    '│',
    '─',
    // Next.js noise
    '▲ Next.js',
    '- Local:',
    '- Network:',
    // Edge Functions noise
    'Serving functions on',
  ];

  const important = [
    'error',
    'Error',
    'ERROR',
    'warning',
    'Warning',
    'WARNING',
    'Started',
    'Ready in',
    'failed',
    'Failed',
    'NOTICE',
  ];

  // Empty or whitespace-only lines are noise
  if (!line.trim()) return false;

  // Check for noise patterns first (exclude these)
  if (noise.some((n) => line.includes(n))) return false;

  // Check for important patterns (include these)
  if (important.some((i) => line.includes(i))) return true;

  // Default: don't show
  return false;
}

/**
 * Attaches filtered output handlers that only show important lines unless VERBOSE is set.
 */
export function attachFilteredOutputHandlers(proc, prefix, color) {
  const writeFiltered = (data, stream) => {
    if (VERBOSE) {
      stream.write(`${color}[${prefix}]${colors.reset} ${data}`);
      return;
    }

    for (const line of data.toString().split('\n')) {
      if (isImportantLine(line)) {
        stream.write(`${color}[${prefix}]${colors.reset} ${line}\n`);
      }
    }
  };

  proc.stdout.on('data', (data) => writeFiltered(data, process.stdout));
  proc.stderr.on('data', (data) => writeFiltered(data, process.stderr));
}

export function log(prefix, color, message) {
  console.log(`${color}[${prefix}]${colors.reset} ${message}`);
}

export function logInfo(message) {
  log('INFO', colors.cyan, message);
}

export function checkDockerRunning() {
  try {
    execSync('docker info', { stdio: 'pipe' });
    return true;
  } catch {
    log(
      'ERROR',
      colors.red,
      'Docker is not running. Please start Docker Desktop.',
    );
    process.exit(1);
  }
}

export function checkDependencies() {
  try {
    execSync('supabase --version', { stdio: 'pipe' });
  } catch {
    log(
      'ERROR',
      colors.red,
      'Supabase CLI not installed. Run: npm install -g supabase',
    );
    process.exit(1);
  }

  try {
    execSync('stripe --version', { stdio: 'pipe' });
  } catch {
    log(
      'WARN',
      colors.yellow,
      'Stripe CLI not installed. Stripe webhooks will be skipped.',
    );
    log('WARN', colors.yellow, 'Install with: winget install Stripe.StripeCLI');
    return { hasStripe: false };
  }

  return { hasStripe: true };
}

export async function startSupabase() {
  log('SUPABASE', colors.green, 'Starting Supabase...');

  // Attempt to stop any previous Supabase instance - errors are expected if none running
  try {
    execSync('supabase stop --no-backup', { cwd: SUPABASE_DIR, stdio: 'pipe' });
  } catch {
    // Ignore: no previous instance to stop
  }

  // Clean up any orphaned Supabase containers - errors are expected if Docker has none
  try {
    const containers = execSync('docker ps -aq --filter "name=supabase_"', {
      encoding: 'utf-8',
      stdio: 'pipe',
    }).trim();
    if (containers) {
      for (const id of containers.split('\n').filter(Boolean)) {
        try {
          execSync(`docker rm -f ${id}`, { stdio: 'pipe' });
        } catch {
          // Ignore: container may have been removed by another process
        }
      }
    }
  } catch {
    // Ignore: docker command may fail if no containers match filter
  }

  return new Promise((resolve, reject) => {
    const proc = shellSpawn('supabase', ['start'], {
      cwd: SUPABASE_DIR,
      stdio: 'pipe',
    });

    let output = '';

    // Helper to write filtered output
    const writeFiltered = (data, stream) => {
      if (VERBOSE) {
        stream.write(`${colors.green}[SUPABASE]${colors.reset} ${data}`);
        return;
      }

      for (const line of data.toString().split('\n')) {
        if (isImportantLine(line)) {
          stream.write(`${colors.green}[SUPABASE]${colors.reset} ${line}\n`);
        }
      }
    };

    // Capture output for parsing while also displaying filtered output
    proc.stdout.on('data', (data) => {
      output += data.toString();
      writeFiltered(data, process.stdout);
    });

    proc.stderr.on('data', (data) => {
      output += data.toString();
      writeFiltered(data, process.stderr);
    });

    proc.on('error', (err) => {
      reject(new Error(`Failed to spawn Supabase process: ${err.message}`));
    });

    proc.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Supabase start failed with code ${code}`));
        return;
      }
      resolve(parseSupabaseOutput(output));
    });
  });
}

function parseSupabaseOutput(output) {
  // Default to known local ports (Supabase CLI uses deterministic ports)
  const creds = {
    studioUrl: 'http://127.0.0.1:54323',
  };

  const lines = output.split('\n');

  for (const line of lines) {
    // Old format: "API URL: http://..."
    if (line.includes('API URL:')) {
      creds.apiUrl = line.split('API URL:')[1].trim();
    } else if (line.includes('anon key:')) {
      creds.anonKey = line.split('anon key:')[1].trim();
    } else if (line.includes('service_role key:')) {
      creds.serviceRoleKey = line.split('service_role key:')[1].trim();
    } else if (line.includes('Studio URL:')) {
      creds.studioUrl = line.split('Studio URL:')[1].trim();
    }

    // New format (ASCII boxes): "│ Studio  │ http://127.0.0.1:54323 │"
    const studioMatch = line.match(/│\s*Studio\s*│\s*(http[^\s│]+)/);
    if (studioMatch) {
      creds.studioUrl = studioMatch[1];
    }
  }

  return creds;
}

/**
 * Starts the Stripe webhook listener and extracts the webhook secret from output.
 * @returns {Promise<{proc: import('node:child_process').ChildProcess|null, webhookSecret: string|null}>}
 */
export async function startStripeWebhook() {
  log('STRIPE', colors.magenta, 'Starting Stripe webhook listener...');

  return new Promise((resolve) => {
    const proc = shellSpawn(
      'stripe',
      ['listen', '--forward-to', 'localhost:3000/api/webhooks/stripe'],
      { stdio: 'pipe' },
    );

    let resolved = false;
    let timeoutId;

    const resolveOnce = (result) => {
      if (resolved) return;
      resolved = true;
      clearTimeout(timeoutId);
      resolve(result);
    };

    const handleOutput = (data, stream) => {
      const output = data.toString();
      if (VERBOSE) {
        stream.write(`${colors.magenta}[STRIPE]${colors.reset} ${output}`);
      }

      // Extract webhook secret from Stripe CLI output
      const match = output.match(/whsec_[a-zA-Z0-9]+/);
      if (!match) return;

      log('STRIPE', colors.magenta, `Webhook secret: ${match[0]}`);
      resolveOnce({ proc, webhookSecret: match[0] });
    };

    proc.stdout.on('data', (data) => handleOutput(data, process.stdout));
    proc.stderr.on('data', (data) => handleOutput(data, process.stderr));

    proc.on('error', (err) => {
      log('STRIPE', colors.red, `Failed to start: ${err.message}`);
      resolveOnce({ proc: null, webhookSecret: null });
    });

    timeoutId = setTimeout(() => {
      if (!resolved) {
        log('STRIPE', colors.yellow, 'Timeout waiting for webhook secret');
      }
      resolveOnce({ proc, webhookSecret: null });
    }, STRIPE_WEBHOOK_TIMEOUT_MS);
  });
}

/**
 * Updates or adds an environment variable in the content string.
 * @param {string} content - Current env file content
 * @param {string} key - Environment variable name
 * @param {string} value - Environment variable value
 * @returns {string} Updated content
 */
function setEnvVar(content, key, value) {
  const regex = new RegExp(`^${key}=.*$`, 'm');
  const newLine = `${key}=${value}`;
  return regex.test(content)
    ? content.replace(regex, newLine)
    : `${content}\n${newLine}`;
}

/**
 * Updates the dashboard .env.local file with fixed local Supabase credentials.
 * Uses deterministic values so Next.js build can run in parallel with Supabase start.
 */
export function updateEnvFile(stripeWebhookSecret) {
  let envContent = existsSync(ENV_FILE) ? readFileSync(ENV_FILE, 'utf-8') : '';

  // Use fixed local development values for deterministic builds
  const updates = {
    NEXT_PUBLIC_SUPABASE_URL: LOCAL_SUPABASE_URL,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: LOCAL_ANON_KEY,
    SUPABASE_SERVICE_KEY: LOCAL_SERVICE_ROLE_KEY,
    NEXT_PUBLIC_GATEWAY_URL: LOCAL_SUPABASE_URL,
    ...(stripeWebhookSecret && { STRIPE_WEBHOOK_SECRET: stripeWebhookSecret }),
  };

  for (const [key, value] of Object.entries(updates)) {
    envContent = setEnvVar(envContent, key, value);
  }

  writeFileSync(ENV_FILE, `${envContent.trim()}\n`);
  log('ENV', colors.cyan, `Updated ${ENV_FILE}`);
}

export function startSupabaseFunctions() {
  log('FUNCTIONS', colors.yellow, 'Starting Supabase Edge Functions...');
  return spawnWithPrefix(
    'supabase',
    ['functions', 'serve', '--env-file', join(SUPABASE_DIR, '.env.local')],
    SUPABASE_DIR,
    'FUNCTIONS',
    colors.yellow,
  );
}

export function spawnWithPrefix(command, args, cwd, prefix, color) {
  const proc = shellSpawn(command, args, { cwd, stdio: 'pipe' });

  // Use filtered output unless in verbose mode
  attachFilteredOutputHandlers(proc, prefix, color);

  proc.on('error', (err) => {
    log(prefix, colors.red, `Failed to spawn process: ${err.message}`);
  });

  return proc;
}

export function setupCleanup(processes, stopSupabase = true) {
  const cleanup = () => {
    log('INFO', colors.yellow, '\nShutting down...');
    for (const proc of processes) {
      proc?.kill();
    }

    if (stopSupabase) {
      log('INFO', colors.yellow, 'Stopping Supabase...');
      try {
        execSync('supabase stop', { cwd: SUPABASE_DIR, stdio: 'inherit' });
      } catch {
        // Ignore: best-effort cleanup during shutdown
      }
    }

    process.exit(0);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
}

export function copyTypes() {
  log('TYPES', colors.yellow, 'Copying shared types to Edge Functions...');
  try {
    execSync('turbo run //#copy-types', { stdio: 'pipe' });
    log('TYPES', colors.yellow, 'Done');
  } catch (err) {
    // Show error output if it fails
    if (err.stdout) process.stdout.write(err.stdout);
    if (err.stderr) process.stderr.write(err.stderr);
    throw err;
  }
}

/**
 * Generates seed.sql from seed.sql.template using environment variables.
 * Must be called before Supabase starts so the seed is applied correctly.
 */
export function generateSeed() {
  log('SEED', colors.green, 'Generating seed.sql from template...');
  try {
    execSync('node scripts/generate-seed.js', {
      cwd: SUPABASE_DIR,
      stdio: 'pipe',
    });
    log('SEED', colors.green, 'Done');
  } catch (err) {
    // Show error output if it fails
    if (err.stdout) process.stdout.write(err.stdout);
    if (err.stderr) process.stderr.write(err.stderr);
    throw new Error('Failed to generate seed.sql - check your .env.local');
  }
}

/**
 * Performs common initialization for dev/start scripts:
 * - Checks Docker is running
 * - Checks dependencies (Supabase CLI, optionally Stripe CLI)
 * - Generates seed.sql from template (before Supabase starts)
 * - Copies shared types to Edge Functions
 * - Starts Stripe webhook listener (if available)
 * - Updates .env.local with local credentials
 *
 * @returns {Promise<{stripeProc: ChildProcess|null, stripeWebhookSecret: string|null}>}
 */
export async function initializeEnvironment() {
  checkDockerRunning();
  const { hasStripe } = checkDependencies();
  generateSeed();
  copyTypes();

  let stripeProc = null;
  let stripeWebhookSecret = null;

  if (hasStripe) {
    const stripe = await startStripeWebhook();
    stripeProc = stripe.proc;
    stripeWebhookSecret = stripe.webhookSecret;
  }

  updateEnvFile(stripeWebhookSecret);

  return { stripeProc, stripeWebhookSecret };
}
