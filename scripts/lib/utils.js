import { execSync, spawn } from 'node:child_process';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

export const __dirname = dirname(fileURLToPath(import.meta.url));
export const ROOT = join(__dirname, '..', '..');
export const SUPABASE_DIR = join(ROOT, 'packages', 'supabase');
export const DASHBOARD_DIR = join(ROOT, 'apps', 'dashboard');
export const ENV_FILE = join(DASHBOARD_DIR, '.env.local');

// Fixed local development credentials (deterministic for parallel builds)
// These are generated by Supabase CLI based on project_id "fieldmcp" and are consistent across runs
export const LOCAL_SUPABASE_URL = 'http://127.0.0.1:54321';
export const LOCAL_ANON_KEY = 'sb_publishable_ACJWlzQHlZjBrEguHvfOxg_3BJgxAaH';
export const LOCAL_SERVICE_ROLE_KEY =
  'sb_secret_N7UND0UgjKTVK-Uodkm0Hg_xSvEMPvz';

export const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// Constants for timeouts
const STRIPE_WEBHOOK_TIMEOUT_MS = 10000;

/**
 * Attaches prefixed output handlers to a spawned process's stdout/stderr streams.
 * @param {import('node:child_process').ChildProcess} proc - The spawned process
 * @param {string} prefix - The prefix label (e.g., 'NEXT', 'SUPABASE')
 * @param {string} color - ANSI color code for the prefix
 */
export function attachPrefixedOutputHandlers(proc, prefix, color) {
  proc.stdout.on('data', (data) => {
    process.stdout.write(`${color}[${prefix}]${colors.reset} ${data}`);
  });

  proc.stderr.on('data', (data) => {
    process.stderr.write(`${color}[${prefix}]${colors.reset} ${data}`);
  });
}

export function log(prefix, color, message) {
  console.log(`${color}[${prefix}]${colors.reset} ${message}`);
}

export function logInfo(message) {
  log('INFO', colors.cyan, message);
}

export function checkDockerRunning() {
  try {
    execSync('docker info', { stdio: 'pipe' });
    return true;
  } catch {
    log(
      'ERROR',
      colors.red,
      'Docker is not running. Please start Docker Desktop.',
    );
    process.exit(1);
  }
}

export function checkDependencies() {
  try {
    execSync('supabase --version', { stdio: 'pipe' });
  } catch {
    log(
      'ERROR',
      colors.red,
      'Supabase CLI not installed. Run: npm install -g supabase',
    );
    process.exit(1);
  }

  try {
    execSync('stripe --version', { stdio: 'pipe' });
  } catch {
    log(
      'WARN',
      colors.yellow,
      'Stripe CLI not installed. Stripe webhooks will be skipped.',
    );
    log('WARN', colors.yellow, 'Install with: winget install Stripe.StripeCLI');
    return { hasStripe: false };
  }

  return { hasStripe: true };
}

export async function startSupabase() {
  log('SUPABASE', colors.green, 'Starting Supabase...');

  // Attempt to stop any previous Supabase instance - errors are expected if none running
  try {
    execSync('supabase stop --no-backup', { cwd: SUPABASE_DIR, stdio: 'pipe' });
  } catch {
    // Ignore: no previous instance to stop
  }

  // Clean up any orphaned Supabase containers - errors are expected if Docker has none
  try {
    const containers = execSync('docker ps -aq --filter "name=supabase_"', {
      encoding: 'utf-8',
      stdio: 'pipe',
    }).trim();
    if (containers) {
      for (const id of containers.split('\n').filter(Boolean)) {
        try {
          execSync(`docker rm -f ${id}`, { stdio: 'pipe' });
        } catch {
          // Ignore: container may have been removed by another process
        }
      }
    }
  } catch {
    // Ignore: docker command may fail if no containers match filter
  }

  return new Promise((resolve, reject) => {
    const proc = spawn('supabase', ['start'], {
      cwd: SUPABASE_DIR,
      shell: true,
      stdio: 'pipe',
    });

    let output = '';

    // Capture output for parsing while also displaying with prefix
    proc.stdout.on('data', (data) => {
      output += data.toString();
      process.stdout.write(`${colors.green}[SUPABASE]${colors.reset} ${data}`);
    });

    proc.stderr.on('data', (data) => {
      output += data.toString();
      process.stderr.write(`${colors.green}[SUPABASE]${colors.reset} ${data}`);
    });

    proc.on('error', (err) => {
      reject(new Error(`Failed to spawn Supabase process: ${err.message}`));
    });

    proc.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Supabase start failed with code ${code}`));
        return;
      }
      resolve(parseSupabaseOutput(output));
    });
  });
}

function parseSupabaseOutput(output) {
  const lines = output.split('\n');
  const creds = {};

  for (const line of lines) {
    if (line.includes('API URL:')) {
      creds.apiUrl = line.split('API URL:')[1].trim();
    } else if (line.includes('anon key:')) {
      creds.anonKey = line.split('anon key:')[1].trim();
    } else if (line.includes('service_role key:')) {
      creds.serviceRoleKey = line.split('service_role key:')[1].trim();
    } else if (line.includes('Studio URL:')) {
      creds.studioUrl = line.split('Studio URL:')[1].trim();
    }
  }

  return creds;
}

/**
 * Starts the Stripe webhook listener and extracts the webhook secret from output.
 * @returns {Promise<{proc: import('node:child_process').ChildProcess|null, webhookSecret: string|null}>}
 */
export async function startStripeWebhook() {
  log('STRIPE', colors.magenta, 'Starting Stripe webhook listener...');

  return new Promise((resolve) => {
    const proc = spawn(
      'stripe',
      ['listen', '--forward-to', 'localhost:3000/api/webhooks/stripe'],
      { shell: true, stdio: 'pipe' },
    );

    let resolved = false;

    const resolveOnce = (result) => {
      if (resolved) return;
      resolved = true;
      resolve(result);
    };

    const handleOutput = (data, stream) => {
      const output = data.toString();
      stream.write(`${colors.magenta}[STRIPE]${colors.reset} ${output}`);

      // Extract webhook secret from Stripe CLI output
      const match = output.match(/whsec_[a-zA-Z0-9]+/);
      if (!match) return;

      log('STRIPE', colors.magenta, `Webhook secret: ${match[0]}`);
      resolveOnce({ proc, webhookSecret: match[0] });
    };

    proc.stdout.on('data', (data) => handleOutput(data, process.stdout));
    proc.stderr.on('data', (data) => handleOutput(data, process.stderr));

    proc.on('error', (err) => {
      log('STRIPE', colors.red, `Failed to start: ${err.message}`);
      resolveOnce({ proc: null, webhookSecret: null });
    });

    setTimeout(() => {
      log('STRIPE', colors.yellow, 'Timeout waiting for webhook secret');
      resolveOnce({ proc, webhookSecret: null });
    }, STRIPE_WEBHOOK_TIMEOUT_MS);
  });
}

/**
 * Updates or adds an environment variable in the content string.
 * @param {string} content - Current env file content
 * @param {string} key - Environment variable name
 * @param {string} value - Environment variable value
 * @returns {string} Updated content
 */
function setEnvVar(content, key, value) {
  const regex = new RegExp(`^${key}=.*$`, 'm');
  const newLine = `${key}=${value}`;
  return regex.test(content)
    ? content.replace(regex, newLine)
    : `${content}\n${newLine}`;
}

/**
 * Updates the dashboard .env.local file with fixed local Supabase credentials.
 * Uses deterministic values so Next.js build can run in parallel with Supabase start.
 */
export function updateEnvFile(stripeWebhookSecret) {
  let envContent = existsSync(ENV_FILE) ? readFileSync(ENV_FILE, 'utf-8') : '';

  // Use fixed local development values for deterministic builds
  const updates = {
    NEXT_PUBLIC_SUPABASE_URL: LOCAL_SUPABASE_URL,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: LOCAL_ANON_KEY,
    SUPABASE_SERVICE_KEY: LOCAL_SERVICE_ROLE_KEY,
    NEXT_PUBLIC_GATEWAY_URL: LOCAL_SUPABASE_URL,
    ...(stripeWebhookSecret && { STRIPE_WEBHOOK_SECRET: stripeWebhookSecret }),
  };

  for (const [key, value] of Object.entries(updates)) {
    envContent = setEnvVar(envContent, key, value);
  }

  writeFileSync(ENV_FILE, `${envContent.trim()}\n`);
  log('ENV', colors.cyan, `Updated ${ENV_FILE}`);
}

export function startSupabaseFunctions() {
  log('FUNCTIONS', colors.yellow, 'Starting Supabase Edge Functions...');
  return spawnWithPrefix(
    'supabase',
    ['functions', 'serve', '--env-file', join(SUPABASE_DIR, '.env.local')],
    SUPABASE_DIR,
    'FUNCTIONS',
    colors.yellow,
  );
}

export function spawnWithPrefix(command, args, cwd, prefix, color) {
  const proc = spawn(command, args, { cwd, shell: true, stdio: 'pipe' });

  attachPrefixedOutputHandlers(proc, prefix, color);

  proc.on('error', (err) => {
    log(prefix, colors.red, `Failed to spawn process: ${err.message}`);
  });

  return proc;
}

export function setupCleanup(processes, stopSupabase = true) {
  const cleanup = () => {
    log('INFO', colors.yellow, '\nShutting down...');
    for (const proc of processes) {
      proc?.kill();
    }

    if (stopSupabase) {
      log('INFO', colors.yellow, 'Stopping Supabase...');
      try {
        execSync('supabase stop', { cwd: SUPABASE_DIR, stdio: 'inherit' });
      } catch {
        // Ignore: best-effort cleanup during shutdown
      }
    }

    process.exit(0);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
}

export function copyTypes() {
  log('TYPES', colors.yellow, 'Copying shared types to Edge Functions...');
  execSync('turbo run //#copy-types', { stdio: 'inherit' });
}

/**
 * Performs common initialization for dev/start scripts:
 * - Checks Docker is running
 * - Checks dependencies (Supabase CLI, optionally Stripe CLI)
 * - Copies shared types to Edge Functions
 * - Starts Stripe webhook listener (if available)
 * - Updates .env.local with local credentials
 *
 * @returns {Promise<{stripeProc: ChildProcess|null, stripeWebhookSecret: string|null}>}
 */
export async function initializeEnvironment() {
  checkDockerRunning();
  const { hasStripe } = checkDependencies();
  copyTypes();

  let stripeProc = null;
  let stripeWebhookSecret = null;

  if (hasStripe) {
    const stripe = await startStripeWebhook();
    stripeProc = stripe.proc;
    stripeWebhookSecret = stripe.webhookSecret;
  }

  updateEnvFile(stripeWebhookSecret);

  return { stripeProc, stripeWebhookSecret };
}
